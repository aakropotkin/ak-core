#! /usr/bin/env bash
# ============================================================================ #
#
# Add entry to \`compile_commands.json'.
#
# This script may be executed directly or sourced and invoked as `ccjs_add'.
#
#
# ---------------------------------------------------------------------------- #

_OLD_OPTS="$( set +o; )";
set -eu;
set -o pipefail;


# ---------------------------------------------------------------------------- #

if [[ "${BASH_SOURCE[0]}" = "$0" ]]; then
  _as_me="ccjs_add";
  _usage_add_msg="USAGE: $_as_me [CMD-OPTIONS]... FILE OUTPUT DIRECTORY \
ARGS...";
else
  _usage_add_msg="USAGE: ${_as_me:-ccjs} [OPTIONS...] add [CMD-OPTIONS]... \
FILE OUTPUT DIRECTORY ARGS...";
fi

_usage_add_msg="$_usage_add_msg

Add entry to \`compile_commands.json'.
";

_help_add_msg="$_usage_add_msg
Replaces existing entry if it exists.

When \`--in-place' is specified, \`compile_commands.json' is modified in-place
instead of being printed to \`STDOUT'.
Existing output file will be backed up by adding a \`~' suffix to its name.

ARGUMENTS
  FILE              The source file to compile ( e.g. \`foo.c' ).
  OUTPUT            The output file ( e.g. \`foo.o' ).
  DIRECTORY         The directory in which to run the compiler.

OPTIONS
  -h,--help         Print help message to STDOUT.
  -u,--usage        Print usage message to STDOUT.
  -i,--in-place     Add entry to \`compile_commands.json' in-place.

ENVIRONMENT
  CCJS_OUT            Output file. Default: \`./compile_commands.json'.
  JQ                  Command used as \`jq' executable.
  REALPATH            Command used as \`realpath' executable.
  MKTEMP              Command used as \`mktemp' executable.
";


# ---------------------------------------------------------------------------- #

usage_add() {
  if [[ "${1:-}" = "-f" ]]; then
    echo "$_help_add_msg";
  else
    echo "$_usage_add_msg";
  fi
}


# ---------------------------------------------------------------------------- #

# @BEGIN_INJECT_UTILS@
: "${JQ:=jq}";
: "${REALPATH:=realpath}";
: "${MKTEMP:=mktemp}";
export JQ REALPATH MKTEMP;
# @END_INJECT_UTILS@


# ---------------------------------------------------------------------------- #

ccjs_add() {
  _IN_PLACE='';
  _FILE='';
  _OUTPUT='';
  _DIRECTORY='';

  declare -a _cc_args;
  _cc_args=();

  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      -u|--usage)    usage_add;    exit 0; ;;
      -h|--help)     usage_add -f; exit 0; ;;
      -i|--in-place) _IN_PLACE=:;  ;;
      --) shift; break; ;;
      *)
        if [[ -z "$_FILE" ]]; then
          _FILE="$1";
        elif [[ -z "$_OUTPUT" ]]; then
          _OUTPUT="$1";
        elif [[ -z "$_DIRECTORY" ]]; then
          _DIRECTORY="$1";
        else
          _cc_args+=( "$1" );
        fi
      ;;
    esac
    shift;
  done
  # Add remaining arguments to \`_cc_args'.
  if [[ -n "$*" ]]; then
    _cc_args+=( "$@" );
  fi


  # Get absolute paths.

  case "${CCJS_OUT:=$PWD/compile_commands.json}" in
    /*) :; ;;
    *) CCJS_OUT="$( "$REALPATH" "$CCJS_OUT"; )"; ;;
  esac

  case "$_FILE" in
    "") echo "$_as_me: Missing FILE argument." >&2; usage_add >&2; exit 1; ;;
    /*) :; ;;
    *) _FILE="$( "$REALPATH" -m "$_FILE"; )"; ;;
  esac

  case "${_OUTPUT:=${_FILE%.*}.o}" in
    /*) :; ;;
    *) _OUTPUT="$( "$REALPATH" -m "$_OUTPUT"; )"; ;;
  esac

  case "${_DIRECTORY:=$PWD}" in
    /*) :; ;;
    *) _DIRECTORY="$( "$REALPATH" -m "$_DIRECTORY"; )"; ;;
  esac


  # Create entry

  _ARGS='';
  for _arg in "${_cc_args[@]}"; do
    # Escape double quotes.
    _ARGS="${_ARGS:+$_ARGS, }\"${_arg//\"/\\\"}\"";
  done

  _ENTRY="{
    \"directory\": \"$_DIRECTORY\",
    \"file\": \"$_FILE\",
    \"output\": \"$_OUTPUT\",
    \"arguments\": [$_ARGS]
  }";


  # If there's an existing file add the entry to it, otherwise just make a
  # singleton list with the entry.
  if ! [[ -f "$CCJS_OUT" ]]; then
    # If the file doesn't exist create it.
    if [[ -n "$_IN_PLACE" ]]; then
      echo "[$_ENTRY]"|$JQ > "$CCJS_OUT";
    else
      echo "[$_ENTRY]"|$JQ;
    fi
  else
    # If we are being run directly we don't have `mktmp_auto' available.
    if [[ -n "${_TMP_FILES+y}" ]]; then
      TMPFILE="$( mktmp_auto; )";
    else
      TMPFILE="$( $MKTEMP; )";
      _es=0;
      trap '_es="$?"; rm -f "$TMPFILE"; exit "$_es";' HUP TERM INT QUIT EXIT;
    fi

    _JQ_CMD="[\$_ENTRY] + .|unique_by( .output )";
    if [[ -n "$_IN_PLACE" ]]; then
      # Add the entry to the file, and remove old entry ( if present ).
      $JQ --argjson _ENTRY "$_ENTRY" "$_JQ_CMD" "$CCJS_OUT" > "$TMPFILE";
      # Backup the original file.
      mv "$CCJS_OUT" "$CCJS_OUT~";
      # Overwrite the original file.
      mv "$TMPFILE" "$CCJS_OUT";
    else
      $JQ --argjson _ENTRY "$_ENTRY" "$_JQ_CMD" "$CCJS_OUT";
    fi
  fi
  exit 0;
}


# ---------------------------------------------------------------------------- #

# Restore options.
eval "$_OLD_OPTS";


# ---------------------------------------------------------------------------- #

# If we are being run directly, run the function.
if [[ "${BASH_SOURCE[0]}" = "$0" ]]; then
  ccjs_add "$@";
else
  export -f ccjs_add;
fi


# ---------------------------------------------------------------------------- #
#
#
#
# ============================================================================ #
