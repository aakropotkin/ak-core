#! /usr/bin/env zsh
# -*- mode: shell-script; sh-shell: zsh; -*-
# ============================================================================ #


# ---------------------------------------------------------------------------- #

function usage() {
MESSAGE="\
Usage: syms [OPTION...] FILE...
Print global symbols defined by an ELF file.

Output is generated by wrapping calls to \`nm'.

When \`FILE' is a Shared Object only Dynamic Symbols are printed.

By default symbol names are sorted alphabetically. See \`-p' flag.

By default symbol versions are excluded from output. See \`-V' flag.

When multiple files are provided, filenames will precede symbols.
This is accomplished by passing \`-o' to \`nm', so keep in mind that \`.a'
archive files will be of the form \"FILE:OBJECT: SYMBOL\".
This behavior can be accomplished for a single file with the \`-o' flag.

Depends on \`is-elf-{so,ar,cu}' scripts.

Summary of options:
  -C, --demangle    Demangle C++ symbols.
  -u, --undefined   Print undefined symbols instead of defined symbols.
  -p, --no-sort     Do not sort alphabetically.
  -V, --symver      Print symbol versions as \"SYMBOL VERSION\".
  -o, --fname       Print filenames ( passes \`-o' to \`nm' ).
  -O, --no-fname    Suppress filenames even for \`.a' archives.
  -k, --keep-going  When multiple files are given, skip non-ELF files.
  -h, --help        Print this usage message.";
  echo "${MESSAGE}";
}


# ---------------------------------------------------------------------------- #

declare -a DEPS;
DEPS=( is-elf-so is-elf-cu is-elf-ar nm c++filt );

for dep in ${DEPS[@]}; do
  if ! which ${dep} &>/dev/null; then
    echo "Could not locate dependency : ${dep}!" >&2;
    exit 1;
  fi
done


# ---------------------------------------------------------------------------- #

# Parse options

zparseopts -D C=_demangle  -demangle=_demangle     \
              u=_undefs    -undefined=_undefs      \
              p=_nosort    -no-sort=_nosort        \
              V=_symver    -symver=_symver         \
              o=_fname     -fname=_fname           \
              O=_nofname   -no-fname=_nofname      \
              k=_keepgoing -keep-going=_keepgoing  \
              h=_help      -help=_help;

demangle=${#_demangle};
undefs=${#_undefs};
nosort=${#_nosort};
symver=${#_symver};
fname=${#_fname};
nofname=${#_nofname};
keepgoing=${#_keepgoing};
help=${#_help};


# ---------------------------------------------------------------------------- #

# `-O' and `-o' are mutually exclusive.
if test ${fname} -gt 0 -a ${nofname} -gt 0; then
  echo "The flags \`--fname' and \`--no-fname' are mutually exclusive!" >&2;
  usage >&2;
  exit 2;
fi


# ---------------------------------------------------------------------------- #

# Show Usage if requested

if test ${help} -gt 0; then
  usage;
  exit 0;
fi


# ---------------------------------------------------------------------------- #

# Parse remaining arguments

if test ${#} -lt 1; then
  echo "You must provide at least one file!" >&2;
  usage >&2;
  exit 3;
fi


# ---------------------------------------------------------------------------- #

# Categorize input files

declare -a dfiles;  # Shared Objects
declare -a ofiles;  # Individual Object Files
declare -a afiles;  # Archives

nfiles=0;

for f in ${@}; do
  if is-elf-so ${f}; then
    dfiles+=( ${f} );
    nfiles=$(( nfiles + 1 ));
  elif is-elf-cu ${f}; then
    ofiles+=( ${f} );
    nfiles=$(( nfiles + 1 ));
  elif is-elf-ar ${f}; then
    afiles+=( ${f} );
    nfiles=$(( nfiles + 1 ));
  elif test ${keepgoing} -lt 1 -o ${#} = 1; then
    echo "File \`${f}' is not ELF format!" >&2;
    exit 4;
  fi
done


# ---------------------------------------------------------------------------- #

# Catch Errors

if test ${nfiles} -lt 1; then
  echo "No ELF files were found in input!" >&2;
  echo "FILES: ${@}" >&2;
  exit 5;
fi


# ---------------------------------------------------------------------------- #

# Declare file printing rules

local showfnames=0;
if test ${nofname} -lt 1; then
  if test ${fname} -gt 0 -o ${nfiles} -gt 1; then
    showfnames=1;
  fi
fi


# ---------------------------------------------------------------------------- #

# Construct `nm' flags

NM_OPTS='-gP --no-demangle';

if test ${showfnames} -gt 0; then
  NM_OPTS+=' -o';
fi

if test ${undefs} -gt 0; then
  NM_OPTS+=' -u';
else
  NM_OPTS+=' --defined-only';
fi

if test ${nosort} -gt 0; then
  NM_OPTS+=' -p';
fi

if test ${symver} -gt 0; then
  NM_OPTS+=' --with-symbol-versions';
fi


# ---------------------------------------------------------------------------- #

function assert_readable() {
  if test ! -r ${1}; then
    echo "Could not read file: ${1}" >&2;
    exit 6;
  fi
}


# ---------------------------------------------------------------------------- #
#
# Parse `nm' output and transform it to `printf' style input.
#
# Lines are : "FILE: SYMBOL TYPE HEX HEX"
# or        : "FILE: SYMBOL @<VERSION><TYPE> HEX HEX"
# or        : "FILE: SYMBOL @@VERSION><TYPE> HEX HEX"
# Notably there is no space between the version tag and the symbol "type"
# character which is a real pain.
#
# Output format is space separated as either :
#   For unversioned symbols : "FILE SYMBOL"
#   For versioned symbols   : "FILE SYMBOL VERSION SYMVER_STRENGTH"
#
# At this stage symbols are still mangled, which is the only reason we can parse
# it so easily. Because of this `c++filt' needs to be used to post-process.

if test ${showfnames} -gt 0; then
  alias nmln_to_pargs="sed -r 's/^([^:]+): ([^ ]+) ((@+)([^ ]+))?[^ ] .*$/\1 \2 \5 \4/'";
  alias nmln_to_pargs_a="sed -r 's/^([^:]+): ([^ ]+) ((@+)([^ ]+))?[^ ] .*$/%\1% \2 \5 \4/'";
else
  # When we aren't listing filenames we can drop that part of the filter
  alias nmln_to_pargs="sed -r 's/^([^ ]+) ((@+)([^ ]+))?[^ ] .*$/\1 \4 \3/'";
  alias nmln_to_pargs_a="sed -r 's/^([^:]+): ([^ ]+) ((@+)([^ ]+))?[^ ] .*$/\2 \5 \4/'";
fi


# ---------------------------------------------------------------------------- #

# This is honestly for debugging.
#function printsymbol_detailed() {
#  local FNAME=${1};
#  local MSYM=${2};
#  local SYMVER=${3};
#  local SVSTR=${4};
#
#  local SYM='';
#  if test ${demangle} -gt 0 && echo ${MSYM}|grep -q '^_Z'; then
#    SYM="$( c++filt ${MSYM}; )";
#  else
#    SYM=${MSYM};
#  fi
#
#  echo "File      : ${FNAME}";
#  echo "Mangled   : ${MSYM}";
#  if echo ${MSYM}|grep -q '^_Z'; then
#    echo "Demangled : ${SYM}";
#  fi
#  if test ${#} -gt 2; then
#    printf "Version   : ${SYMVER}";
#    if test "${SVSTR}" = '@@'; then
#      echo " ( Default )";
#    else
#      echo " ( Legacy )";
#    fi
#  fi
#  echo '';
#}


# ---------------------------------------------------------------------------- #

# Print symbol using format provided in first argument.
# Remaining arguments match the output of `nmln_to_pargs'.
#
# Usage : symprintfmt FMT FILE SYMBOL [VERSION SYMVER_STRENGTH]
#
# Format Syntax is a string with `%<SPECIFIER>' elements as follows:
#   %c  Mangled symbol name
#   %C  Demangled symbol name
#   %p  File with full path ( including object for archives )
#   %P  File basename ( including object for archives )
#   %f  File with full path ( no object for archives )
#   %F  File basename ( no object for archives )
#   %o  Object ( only for archives )
#   %v  Symbol version tag ( if present ).
#   %V  Symbol version tag ( if present ) including `@' characters.
#   %s  Symbol version "strength" ( if present ) using `@' characters.
#   %a  Symbol version "strenth" ( if present ) as "default" or "legacy"
#   %A  Symbol version "strenth" ( if present ) as "Default" or "Legacy"
#function symprintfmt() {
#  local FMT=${1};
#  local FNAME=${2};
#  local MSYM=${3};
#  local SYMVER=${4};
#  local SVSTR=${5};
#
#  local numspecs=$( echo "${FMT}"|sed 's/[^%]//g'|wc -L; );
#
#  local spec_c='';
#  local spec_C='';
#  local spec_p='';
#  local spec_P='';
#  local spec_f='';
#  local spec_F='';
#  local spec_o='';
#  local spec_v='';
#  local spec_V='';
#  local spec_s='';
#  local spec_a='';
#  local spec_A='';
#
#
#}


# ---------------------------------------------------------------------------- #

function printsymbol() {
  local kind=${1};  # A, D, or O
  shift;
  local fn='';
  local sv='';
  local svstr='';
  if test ${showfnames} -gt 0; then
    fn="${1}: "; shift;
  fi
  local msym=${1}; shift;
  if test ${symver} -gt 0 -a ${#} -gt 1; then
    sv=${1}; shift;
    svstr=${1}; shift;
  fi
  echo "${fn}${msym}${svstr}${sv}";
}



# ---------------------------------------------------------------------------- #

function run_nm_o() {
  assert_readable ${1};
  local IFS=$'\n';
  for l in $( eval "nm ${NM_OPTS} ${1}|nmln_to_pargs;"; ); do
    eval "printsymbol O ${l};";
  done
}

function run_nm_a() {
  assert_readable ${1};
  local IFS=$'\n';
  for l in $( eval "nm ${NM_OPTS} -o ${1}|nmln_to_pargs_a;"; ); do
    l=$( echo ${l}|tr '%' "'"; );
    eval "printsymbol A ${l};";
  done
}

function run_nm_d() {
  assert_readable ${1};
  local IFS=$'\n';
  for l in $( eval "nm ${NM_OPTS} -D ${1}|nmln_to_pargs;"; ); do
    eval "printsymbol D ${l};";
  done
}


# ---------------------------------------------------------------------------- #

function run_all() {
  for f in ${dfiles[@]}; do
    run_nm_d ${f};
  done

  for f in ${afiles[@]}; do
    run_nm_a ${f};
  done

  for f in ${ofiles[@]}; do
    run_nm_o ${f};
  done
}


# ---------------------------------------------------------------------------- #

RUNCMD='run_all';

if test ${demangle} -gt 0; then
  RUNCMD+='|c++filt';
fi

if test ${nosort} -lt 1; then
  RUNCMD+='|sort|uniq';
fi

eval "${RUNCMD};";


# ---------------------------------------------------------------------------- #



# ============================================================================ #
# vim: set filetype=zsh :
